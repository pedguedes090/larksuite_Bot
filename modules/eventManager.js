// modules/eventManager.js
import fs from 'fs';
import path from 'path';

class EventManager {
  static instance = null;
  
  constructor() {
    if (EventManager.instance) {
      return EventManager.instance;
    }
    
    this.dataFile = path.join(process.cwd(), 'data', 'events.json');
    this.ensureDataDirectory();
    this.activeEvents = {};
    this.eventHistory = [];
    this.scheduledEvents = [];
    
    // Load d·ªØ li·ªáu t·ª´ file
    this.loadData();
    
    // Kh·ªüi t·∫°o c√°c s·ª± ki·ªán t·ª± ƒë·ªông theo gi·ªù
    this.initializeScheduledEvents();
    
    // B·∫Øt ƒë·∫ßu timer ƒë·ªÉ ki·ªÉm tra s·ª± ki·ªán
    this.startEventTimer();
    
    EventManager.instance = this;
  }

  static getInstance() {
    if (!EventManager.instance) {
      EventManager.instance = new EventManager();
    }
    return EventManager.instance;
  }

  ensureDataDirectory() {
    const dataDir = path.dirname(this.dataFile);
    if (!fs.existsSync(dataDir)) {
      fs.mkdirSync(dataDir, { recursive: true });
      console.log('üìÅ ƒê√£ t·∫°o th∆∞ m·ª•c data/ cho events');
    }
  }

  loadData() {
    try {
      if (fs.existsSync(this.dataFile)) {
        const data = JSON.parse(fs.readFileSync(this.dataFile, 'utf8'));
        this.activeEvents = data.activeEvents || {};
        this.eventHistory = data.eventHistory || [];
        this.scheduledEvents = data.scheduledEvents || [];
        console.log(`üìñ Loaded ${Object.keys(this.activeEvents).length} active events`);
      }
    } catch (err) {
      console.error('‚ùå L·ªói ƒë·ªçc file events.json:', err.message);
    }
  }

  saveData() {
    try {
      const data = {
        activeEvents: this.activeEvents,
        eventHistory: this.eventHistory,
        scheduledEvents: this.scheduledEvents
      };
      fs.writeFileSync(this.dataFile, JSON.stringify(data, null, 2), 'utf8');
    } catch (err) {
      console.error('‚ùå L·ªói ghi file events.json:', err.message);
    }
  }

  // Kh·ªüi t·∫°o c√°c s·ª± ki·ªán t·ª± ƒë·ªông theo gi·ªù
  initializeScheduledEvents() {
    const now = new Date();
    const currentHour = now.getHours();
    const currentMinute = now.getMinutes();
    
    // S·ª± ki·ªán h√†ng ng√†y
    const dailyEvents = [
      // Bu·ªïi t·ªëi (gi·ªØ nguy√™n)
      {
        name: 'world_boss',
        title: 'üêâ Boss Th·∫ø Gi·ªõi Xu·∫•t Hi·ªán',
        description: 'Boss th·∫ø gi·ªõi xu·∫•t hi·ªán! Tham gia ngay trong 5 ph√∫t!',
        startHour: 20, // 20:00
        startMinute: 0,
        duration: 5 * 60 * 1000, // 5 ph√∫t
        type: 'world_boss',
        multiplier: 2.0,
        autoStart: true
      },
      // Bu·ªïi s√°ng
      {
        name: 'world_boss_morning',
        title: 'üêâ Boss Th·∫ø Gi·ªõi Xu·∫•t Hi·ªán (S√°ng)',
        description: 'Boss th·∫ø gi·ªõi xu·∫•t hi·ªán bu·ªïi s√°ng! Tham gia ngay trong 5 ph√∫t!',
        startHour: 8, // 08:00
        startMinute: 0,
        duration: 5 * 60 * 1000,
        type: 'world_boss',
        multiplier: 2.0,
        autoStart: true
      },
      {
        name: 'happy_hour_taxiu',
        title: 'üéâ Happy Hour T√†i X·ªâu',
        description: 'T√†i x·ªâu g·∫•p ƒë√¥i th∆∞·ªüng trong 15 ph√∫t!',
        startHour: 19, // 19:00
        startMinute: 0,
        duration: 15 * 60 * 1000, // 15 ph√∫t
        type: 'taxiu',
        multiplier: 2.0,
        autoStart: true
      },
      {
        name: 'happy_hour_taxiu_morning',
        title: 'üéâ Happy Hour T√†i X·ªâu (S√°ng)',
        description: 'T√†i x·ªâu g·∫•p ƒë√¥i th∆∞·ªüng bu·ªïi s√°ng trong 15 ph√∫t!',
        startHour: 10, // 10:00
        startMinute: 0,
        duration: 15 * 60 * 1000,
        type: 'taxiu',
        multiplier: 2.0,
        autoStart: true
      },
      {
        name: 'happy_hour_baucua',
        title: 'üé≤ Happy Hour B·∫ßu Cua',
        description: 'B·∫ßu cua g·∫•p ƒë√¥i th∆∞·ªüng trong 15 ph√∫t!',
        startHour: 21, // 21:00
        startMinute: 0,
        duration: 15 * 60 * 1000, // 15 ph√∫t
        type: 'baucua',
        multiplier: 2.0,
        autoStart: true
      },
      {
        name: 'happy_hour_baucua_morning',
        title: 'üé≤ Happy Hour B·∫ßu Cua (S√°ng)',
        description: 'B·∫ßu cua g·∫•p ƒë√¥i th∆∞·ªüng bu·ªïi s√°ng trong 15 ph√∫t!',
        startHour: 11,
        startMinute: 30,
        duration: 15 * 60 * 1000,
        type: 'baucua',
        multiplier: 2.0,
        autoStart: true
      },
      {
        name: 'double_xp_worldboss',
        title: '‚≠ê Double XP World Boss',
        description: 'Nh·∫≠n g·∫•p ƒë√¥i XP khi ƒë√°nh qu√°i trong 30 ph√∫t!',
        startHour: 18, // 18:00
        startMinute: 0,
        duration: 30 * 60 * 1000, // 30 ph√∫t
        type: 'world_boss_xp',
        multiplier: 2.0,
        autoStart: true
      },
      {
        name: 'double_xp_worldboss_morning',
        title: '‚≠ê Double XP World Boss (S√°ng)',
        description: 'Nh·∫≠n g·∫•p ƒë√¥i XP khi ƒë√°nh qu√°i bu·ªïi s√°ng trong 30 ph√∫t!',
        startHour: 6,
        startMinute: 0,
        duration: 30 * 60 * 1000,
        type: 'world_boss_xp',
        multiplier: 2.0,
        autoStart: true
      },
      {
        name: 'lucky_slot',
        title: 'üé∞ Lucky Slot Machine',
        description: 'Slot machine c√≥ t·ª∑ l·ªá tr√∫ng cao h∆°n trong 20 ph√∫t!',
        startHour: 22, // 22:00
        startMinute: 0,
        duration: 20 * 60 * 1000, // 20 ph√∫t
        type: 'slot',
        multiplier: 1.5,
        autoStart: true
      },
      {
        name: 'lucky_slot_morning',
        title: 'üé∞ Lucky Slot Machine (S√°ng)',
        description: 'Slot machine c√≥ t·ª∑ l·ªá tr√∫ng cao h∆°n bu·ªïi s√°ng trong 20 ph√∫t!',
        startHour: 9,
        startMinute: 0,
        duration: 20 * 60 * 1000,
        type: 'slot',
        multiplier: 1.5,
        autoStart: true
      },
      {
        name: 'gold_rush',
        title: 'üí∞ Gold Rush',
        description: 'T·∫•t c·∫£ game ƒë·ªÅu c√≥ th∆∞·ªüng ti·ªÅn g·∫•p 1.5 l·∫ßn trong 25 ph√∫t!',
        startHour: 23, // 23:00
        startMinute: 0,
        duration: 25 * 60 * 1000, // 25 ph√∫t
        type: 'global_gold',
        multiplier: 1.5,
        autoStart: true
      },
      {
        name: 'gold_rush_morning',
        title: 'üí∞ Gold Rush (S√°ng)',
        description: 'T·∫•t c·∫£ game ƒë·ªÅu c√≥ th∆∞·ªüng ti·ªÅn g·∫•p 1.5 l·∫ßn bu·ªïi s√°ng trong 25 ph√∫t!',
        startHour: 7,
        startMinute: 30,
        duration: 25 * 60 * 1000,
        type: 'global_gold',
        multiplier: 1.5,
        autoStart: true
      }
    ];

    this.scheduledEvents = dailyEvents;
    this.saveData();
  }

  // B·∫Øt ƒë·∫ßu timer ki·ªÉm tra s·ª± ki·ªán
  startEventTimer() {
    // Ki·ªÉm tra m·ªói ph√∫t
    setInterval(() => {
      this.checkScheduledEvents();
      this.cleanupExpiredEvents();
    }, 60 * 1000); // 1 ph√∫t

    // Ki·ªÉm tra ngay l·∫≠p t·ª©c
    this.checkScheduledEvents();
  }

  // Ki·ªÉm tra v√† kh·ªüi ƒë·ªông s·ª± ki·ªán theo l·ªãch
  checkScheduledEvents() {
    const now = new Date();
    const currentHour = now.getHours();
    const currentMinute = now.getMinutes();
    
    for (const event of this.scheduledEvents) {
      if (!event.autoStart) continue;
      
      // Ki·ªÉm tra xem s·ª± ki·ªán c√≥ n√™n b·∫Øt ƒë·∫ßu kh√¥ng
      if (event.startHour === currentHour && event.startMinute === currentMinute) {
        // Ki·ªÉm tra xem s·ª± ki·ªán ƒë√£ t·ªìn t·∫°i ch∆∞a
        if (!this.isEventActive(event.name)) {
          this.startEvent(event.name, event.duration, {
            title: event.title,
            description: event.description,
            type: event.type,
            multiplier: event.multiplier,
            scheduled: true
          });
          
          console.log(`üéâ S·ª± ki·ªán t·ª± ƒë·ªông b·∫Øt ƒë·∫ßu: ${event.title}`);
        }
      }
    }
  }

  // D·ªçn d·∫πp s·ª± ki·ªán h·∫øt h·∫°n
  cleanupExpiredEvents() {
    const now = Date.now();
    const expiredEvents = [];
    
    for (const [eventName, event] of Object.entries(this.activeEvents)) {
      if (now >= event.end) {
        expiredEvents.push(eventName);
      }
    }
    
    for (const eventName of expiredEvents) {
      this.endEvent(eventName);
    }
  }

  // B·∫Øt ƒë·∫ßu s·ª± ki·ªán
  startEvent(name, durationMs, data = {}) {
    const now = Date.now();
    const event = {
      name,
      start: now,
      end: now + durationMs,
      ...data
    };
    
    this.activeEvents[name] = event;
    
    // Th√™m v√†o l·ªãch s·ª≠
    this.eventHistory.push({
      ...event,
      ended: false
    });
    
    // Gi·ªõi h·∫°n l·ªãch s·ª≠ 100 s·ª± ki·ªán g·∫ßn nh·∫•t
    if (this.eventHistory.length > 100) {
      this.eventHistory = this.eventHistory.slice(-100);
    }
    
    this.saveData();
    
    console.log(`üéâ S·ª± ki·ªán b·∫Øt ƒë·∫ßu: ${name} (${Math.floor(durationMs / 60000)} ph√∫t)`);
    
    return event;
  }

  // K·∫øt th√∫c s·ª± ki·ªán
  endEvent(name) {
    if (this.activeEvents[name]) {
      const event = this.activeEvents[name];
      
      // C·∫≠p nh·∫≠t l·ªãch s·ª≠
      const historyEvent = this.eventHistory.find(h => h.name === name && !h.ended);
      if (historyEvent) {
        historyEvent.ended = true;
        historyEvent.actualEnd = Date.now();
      }
      
      delete this.activeEvents[name];
      this.saveData();
      
      console.log(`‚è∞ S·ª± ki·ªán k·∫øt th√∫c: ${name}`);
      
      return event;
    }
    return null;
  }

  // Ki·ªÉm tra s·ª± ki·ªán c√≥ ƒëang ho·∫°t ƒë·ªông kh√¥ng
  isEventActive(name) {
    const event = this.activeEvents[name];
    return event && Date.now() < event.end;
  }

  // L·∫•y th√¥ng tin s·ª± ki·ªán
  getEvent(name) {
    return this.activeEvents[name];
  }

  // L·∫•y t·∫•t c·∫£ s·ª± ki·ªán ƒëang ho·∫°t ƒë·ªông
  getActiveEvents() {
    const now = Date.now();
    const active = {};
    
    for (const [name, event] of Object.entries(this.activeEvents)) {
      if (now < event.end) {
        active[name] = event;
      }
    }
    
    return active;
  }

  // L·∫•y multiplier cho lo·∫°i s·ª± ki·ªán c·ª• th·ªÉ
  getMultiplier(eventType) {
    const activeEvents = this.getActiveEvents();
    
    for (const event of Object.values(activeEvents)) {
      if (event.type === eventType || event.type === 'global_gold') {
        return event.multiplier || 1.0;
      }
    }
    
    return 1.0;
  }

  // L·∫•y th·ªùi gian c√≤n l·∫°i c·ªßa s·ª± ki·ªán (t√≠nh b·∫±ng gi√¢y)
  getTimeRemaining(name) {
    const event = this.activeEvents[name];
    if (!event) return 0;
    
    const remaining = event.end - Date.now();
    return Math.max(0, Math.floor(remaining / 1000));
  }

  // Format th·ªùi gian c√≤n l·∫°i
  formatTimeRemaining(seconds) {
    if (seconds <= 0) return 'ƒê√£ k·∫øt th√∫c';
    
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    
    if (minutes > 0) {
      return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
    }
    return `${remainingSeconds}s`;
  }

  // T·∫°o th√¥ng b√°o s·ª± ki·ªán
  getEventNotification(event) {
    const timeLeft = this.getTimeRemaining(event.name);
    const timeStr = this.formatTimeRemaining(timeLeft);
    
    return `üéâ **${event.title}** üéâ
${event.description}
‚è∞ **Th·ªùi gian c√≤n l·∫°i:** ${timeStr}
üí∞ **T·ª∑ l·ªá th∆∞·ªüng:** x${event.multiplier}`;
  }

  // L·∫•y danh s√°ch s·ª± ki·ªán s·∫Øp t·ªõi
  getUpcomingEvents() {
    const now = new Date();
    const upcoming = [];
    
    for (const event of this.scheduledEvents) {
      if (!event.autoStart) continue;
      
      const eventTime = new Date();
      eventTime.setHours(event.startHour, event.startMinute, 0, 0);
      
      // N·∫øu s·ª± ki·ªán h√¥m nay ƒë√£ qua, t√≠nh cho ng√†y mai
      if (eventTime <= now) {
        eventTime.setDate(eventTime.getDate() + 1);
      }
      
      const timeUntilEvent = eventTime.getTime() - now.getTime();
      const hoursUntil = Math.floor(timeUntilEvent / (1000 * 60 * 60));
      const minutesUntil = Math.floor((timeUntilEvent % (1000 * 60 * 60)) / (1000 * 60));
      
      upcoming.push({
        ...event,
        nextStart: eventTime,
        timeUntil: timeUntilEvent,
        hoursUntil,
        minutesUntil
      });
    }
    
    return upcoming.sort((a, b) => a.timeUntil - b.timeUntil);
  }

  // L·ªánh admin ƒë·ªÉ b·∫Øt ƒë·∫ßu s·ª± ki·ªán th·ªß c√¥ng
  startManualEvent(name, durationMinutes, data = {}) {
    const durationMs = durationMinutes * 60 * 1000;
    return this.startEvent(name, durationMs, {
      ...data,
      manual: true
    });
  }

  // L·ªánh admin ƒë·ªÉ k·∫øt th√∫c s·ª± ki·ªán th·ªß c√¥ng
  endManualEvent(name) {
    return this.endEvent(name);
  }

  // L·∫•y th·ªëng k√™ s·ª± ki·ªán
  getEventStats() {
    const activeCount = Object.keys(this.getActiveEvents()).length;
    const totalHistory = this.eventHistory.length;
    const completedEvents = this.eventHistory.filter(e => e.ended).length;
    
    return {
      activeCount,
      totalHistory,
      completedEvents,
      upcomingCount: this.getUpcomingEvents().length
    };
  }
}

export default EventManager; 